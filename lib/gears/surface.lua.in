---------------------------------------------------------------------------
-- @author Uli Schlachter
-- @copyright 2012 Uli Schlachter
-- @release @AWESOME_VERSION@
---------------------------------------------------------------------------

local setmetatable = setmetatable
local type = type
local capi = { awesome = awesome }
local cairo = require("lgi").cairo
local color = nil

-- Keep this in sync with build-utils/lgi-check.sh!
local ver_major, ver_minor = string.match(require('lgi.version'), '(%d)%.(%d)')
if tonumber(ver_major) <= 0 and tonumber(ver_minor) < 7 then
    error("lgi too old, need at least version 0.7.0")
end

-- gears.surface
local surface = { mt = {} }

--- Try to convert the argument into an lgi cairo surface.
-- This is usually needed for loading images by file name.
function surface.load(_surface)
    -- Nil is not changed
    if not _surface then
        return nil
    end
    -- lgi cairo surfaces don't get changed either
    if cairo.Surface:is_type_of(_surface) then
        return _surface
    end
    -- Strings are assumed to be file names and get loaded
    if type(_surface) == "string" then
        _surface = capi.awesome.load_image(_surface)
    end
    -- Everything else gets forced into a surface
    return cairo.Surface(_surface, true)
end


--- Compose multiple surfaces as one
--
-- Examples:
--    gears.surface.compose({base_surface,surface2,{layer=other_surface,matrix=matrix},{layer=arr2,x=12}})
--
-- Each table element can be a surface, a path or a table with "x","y","layer","matrix" and "scale" as keys.
-- The matrix are standard cairo matrix
-- @note Please note that the first layer cannot be a table
-- @param layer_table An array of surfaces
-- @return A new composed surface with the same dimensions as layer_table[1]
function surface.compose(layer_table)
    local base,cr,base_w,base_h = nil,nil
    for k=1,#layer_table do --Do NOT use ipairs here as the array have some nils
        local v = layer_table[k]
        if not base then
            base = v
            if type(v) == "string" then
                base = cairo.ImageSurface.create_from_png(base)
                base_w,base_h = surface.get_size(base)
                cr = cairo.Context(base)
            else
                base_w,base_h = surface.get_size(v)
                base = v:create_similar(cairo.Content.COLOR_ALPHA, base_w,base_h)
                cr = cairo.Context(base)
                cr:set_source_surface(v)
                cr:paint()
            end
        elseif v then
            local s,x,y,matrix,scale,height = v,0,0,nil,false,nil
            local layer_type=type(s)
            if layer_type == "table" then
                x,y,matrix,scale,height = v.x,v.y,v.matrix,v.scale,v.height
                s = s.layer
                layer_type = type(s)
            end
            if layer_type == "string" then
                s = cairo.ImageSurface.create_from_png(s)
            elseif layer_type == "userdata" then
                s = surface.load(s)
            end

            if scale then
                local sw,sh = s:get_width(),s:get_height()
                local ratio = ((sw > sh) and sw or sh) / ((height or base_h or 16)-4)
                local matrix2 = cairo.Matrix()
                cairo.Matrix.init_scale(matrix2,ratio,ratio)
                if y == "align" then
                    if base_h > sh then
                        y = (base_h -sh)/2
                    else
                        y = (sh - base_h)/2
                    end
                end
                matrix2:translate(-x,-y)
                local pattern = cairo.Pattern.create_for_surface(s)
                pattern:set_matrix(matrix2)
                cr:set_source(pattern)
            elseif matrix then
                local pattern = cairo.Pattern.create_for_surface(s)
                pattern:set_matrix(matrix)
                cr:set_source(pattern)
                cr:move_to(x,y)
            else
                cr:set_source_surface(s,x,y)
            end
            cr:paint()
        end
    end
    return base
end

function surface.mt:__call(...)
    return surface.load(...)
end

--- Get the size of a cairo surface
-- @param surf The surface you are interested in
-- @return The surface's width and height
function surface.get_size(surf)
    local cr = cairo.Context(surf)
    local x, y, w, h = cr:clip_extents()
    return w, h
end


--- Setup a surface to be transformed
-- @return A new surface
-- @return a context
-- @return the mask surface
function create_transformation_mask(sur,height,width,padding)
    -- Get size
    local ic = surface(sur)
    local icp = cairo.Pattern.create_for_surface(ic)
    local sw,sh = surface.get_size(ic)
    local height,width = height or sh,width or sw
    local padding = padding or 2
    local main_ratio = (sw > sh) and sw or sh
    local ratio = (height-padding) / main_ratio

    -- Create matrix
    local matrix = cairo.Matrix()
    cairo.Matrix.init_scale(matrix,ratio,ratio)
    matrix:translate(height/2-6,padding/2)

    --Copy to surface
    local img = cairo.ImageSurface.create(cairo.Format.ARGB32, width, height)
    local cr = cairo.Context(img)
    cr:set_operator(cairo.Operator.CREAR)
    cr:paint()
    cr:set_operator(cairo.Operator.SOURCE)
    cr:set_matrix(matrix)
    cr:set_source(icp)
    cr:paint()

    --Generate the mask
    local mask = ic:create_similar(cairo.Content.ALPHA, sw, sh)
    local cr4 = cairo.Context(mask)
    cr4:set_source(icp)
    cr4:paint()

    return img,cr,mask
end

--- Return a surface where colors have been replaced by a tint
-- @param sur A surface or image path
-- @param col The tint color
-- @param height The height of the resulting surface
-- @param width The width of the resulting surface
-- @param padding a padding
-- @return A new surface
function surface.tint(sur,col,height,width,padding)
    local img,cr,mask= create_transformation_mask(sur,height,width,padding)

    -- Apply the tint
    cr:set_operator(cairo.Operator.HSL_COLOR)
    if not color then
        color = require("gears.color")
    end
    cr:set_source(color(col))
    cr:mask(cairo.Pattern.create_for_surface(mask))
    return img
end

--- Return a desaturated surface
-- @param sur A surface or image path
-- @param factor The desaturation strength (0-1)
-- @param height The height of the resulting surface
-- @param width The width of the resulting surface
-- @param padding a padding
-- @return A new surface
function surface.desaturate(sur,factor,height,width,padding)
    local img,cr,mask= create_transformation_mask(sur,height,width,padding)
    local factor = factor or 1

    -- Apply desaturation
    cr:set_source_rgba(0,0,0,factor)
    cr:set_operator(cairo.Operator.HSL_SATURATION)
    cr:mask(cairo.Pattern.create_for_surface(mask))

    return img
end

return setmetatable(surface, surface.mt)

-- vim: filetype=lua:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:textwidth=80
