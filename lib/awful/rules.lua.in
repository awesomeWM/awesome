---------------------------------------------------------------------------
-- @author Julien Danjou &lt;julien@danjou.info&gt;
-- @copyright 2009 Julien Danjou
-- @release @AWESOME_VERSION@
---------------------------------------------------------------------------

-- Grab environment we need
local client = client
local table = table
local type = type
local ipairs = ipairs
local pairs = pairs
local aclient = require("awful.client")
local atag = require("awful.tag")
local aplacement = require("awful.placement")

--- Apply rules to clients at startup.
-- awful.rules
local rules = {}

--- This is the global rules table.
-- <p>You should fill this table with your rule and properties to apply.
-- For example, if you want to set xterm maximized at startup, you can add:
-- <br/>
-- <code>
-- { rule = { class = "xterm" },
--   properties = { maximized_vertical = true, maximized_horizontal = true } }
-- </code>
-- </p>
-- <p>If you want to set mplayer floating at startup, you can add:
-- <br/>
-- <code>
-- { rule = { name = "MPlayer" },
--   properties = { floating = true } }
-- </code>
-- </p>
-- <p>If you want to put Firefox on a specific tag at startup, you
-- can add:
-- <br/>
-- <code>
-- { rule = { instance = "firefox" },
--   properties = { tag = mytagobject } }
-- </code>
-- </p>
-- <p>If you want to put Emacs on a specific tag at startup, and
-- immediately switch to that tag you can add:
-- <br/>
-- <code>
-- { rule = { class = "Emacs" },
--   properties = { tag = mytagobject, switchtotag = true } }
-- </code>
-- </p>
-- <p>If you want to apply a custom callback to execute when a rule matched,
-- for example to pause playing music from mpd when you start dosbox, you
-- can add:
-- <br/>
-- <code>
-- { rule = { class = "dosbox" },
--   callback = function(c)
--      awful.util.spawn('mpc pause')
--   end }
-- </code>
-- </p>
-- <p>Note that all "rule" entries need to match. If any of the entry does not
-- match, the rule won't be applied.</p>
-- <p>If a client matches multiple rules, their applied in the order they are
-- put in this global rules table. If the value of a rule is a string, then the
-- match function is used to determine if the client matches the rule.</p>
-- <p>If the value of a property is a function, that function gets called and
-- function's return value is used for the property.</p>
--
-- <p> To match multiple clients to a rule one need to use slightly different 
-- syntax:
-- <br/>
-- <code>
-- { rule_any = { class = { "MPlayer", "Nitrogen" }, instance = { "xterm" } },
--   properties = { floating = true } }
-- </code>
-- </p>
--
-- <p> To match multiple clients with an exception one can couple 'except' or
-- 'except_any' with the rules:
-- <br/>
-- <code>
-- { rule = { class = "Firefox" },
--   except = { instance = "Navigator" },
--   properties = {floating = true},
-- },
-- </code>
-- <br/>
-- <code>
-- { rule_any = { class = { "Pidgin", "Xchat" } },
--   except_any = { role = { "conversation" } },
--   properties = { tag = tags[1][1] }
-- }
-- <br/>
-- <code>
-- { rule = {},
--   except_any = { class = { "Firefox", "Vim" } },
--   properties = { floating = true }
-- }
-- </code>
-- </p>
--
-- @class table
-- @name rules
rules.rules = {}

--- Check if a client matches a rule.
-- @param c The client.
-- @param rule The rule to check.
-- @return True if it matches, false otherwise.
function rules.match(c, rule)
    if not rule then return false end
    for field, value in pairs(rule) do
        if c[field] then
            if type(c[field]) == "string" then
                if not c[field]:match(value) and c[field] ~= value then
                    return false
                end
            elseif c[field] ~= value then
                return false
            end
        else
            return false
        end
    end
    return true
end

--- Check if a client matches any part of a rule.
-- @param c The client.
-- @param rule The rule to check.
-- @return True if at least one rule is matched, false otherwise.
function rules.match_any(c, rule)
    if not rule then return false end
    for field, values in pairs(rule) do
        if c[field] then
            for _, value in ipairs(values) do
                if c[field] == value then
                    return true
                elseif type(c[field]) == "string" and c[field]:match(value) then
                    return true
                end
            end
        end
    end
    return false
end

--- Get list of matching rules for a client.
-- @param c The client.
-- @param _rules The rules to check. List with "rule", "rule_any", "except" and
-- "except_any" keys.
-- @return The list of matched rules.
function rules.matching_rules(c, _rules)
    local result = {}
    for _, entry in ipairs(_rules) do
        if (rules.match(c, entry.rule) or rules.match_any(c, entry.rule_any)) and
            (not rules.match(c, entry.except) and not rules.match_any(c, entry.except_any)) then
            table.insert(result, entry)
        end
    end
    return result
end

--- Check if a client matches a given set of rules.
-- @param c The client.
-- @param rules The rules to check. List with "rule", "rule_any", "except" and
-- "except_any" keys.
-- @return True if at least one rule is matched, false otherwise.
function rules.does_match(c, rules)
    local result = rules.matching_rules(c, rules)
    return #result == 0 and false or result
end

--- Apply awful.rules.rules to a client.
-- @param c The client.
function rules.apply(c)
    local props = {}
    local callbacks = {}

    for _, entry in ipairs(rules.matching_rules(c, rules.rules)) do
        if entry.properties then
            for property, value in pairs(entry.properties) do
                props[property] = value
            end
        end
        if entry.callback then
            table.insert(callbacks, entry.callback)
        end
    end

    rules.execute(c, props, callbacks)
end

--- Get a property value
-- @param c The client.
-- @param property The property name
-- @param value The property value
-- @param ignore_function A table of properties where functions should not be executed
local funcion get_property(c,property,value,ignore_function)
    if not property or not value then return end

    if type(property) ~= "function" or ignore_function[property] then
        return value
    else
        return value(c)
    end
    return  and value or (ignore_function[property] and property or )
end

--- Apply properies to a client
-- @param c The client.
-- @param props Properties to apply.
-- @param ignore_function An optional table of properties where functions should not be executed
-- @return Tags that have been assigned
function rules.apply_properties(c,props,ignore_function)
    if not c or props then return end
    local ignore_function,ret = ignore_function or {"focus"},nil

    -- Make the client floating
    if props.floating then
        aclient.floating.set(c, get_property(c,"floating",props.floating,ignore_function))
        props.floating = nil
    end

    -- Create a new tag if necessary
    if props.new_tag then
        local tag = get_property(c,"new_tag",props.new_tag,ignore_function)
        local tag_type = type(tag)
        if tag_type == "tag" then
            c:tags({tag})
            ret = {tag}
        else
            -- Assume it is a tag property table
            c:tags({atag.add(tag_type=="table" and tag.name or c.class,tag_type=="table" and tag or {})})
        end
        props.new_tag = nil
    -- Assign client to a tag or set of tags
    elseif props.tag or props.tags then
        -- Both cannot be used at once, choose "tag", assume they are equivalent
        local property = props.tag and "tag" or "tags"
        local tags = get_property(c,property,props[property],ignore_function)

        if type(tags) == "table" and #tags > 0 then
            -- Mixing screens for a single client cause issues
            local screen,filtered_tags = atag.getscreen(tags[1]) or c.screen,{}
            for k,t in ipairs(tags) do
                if atag.getscreen(t) == screen then
                    filtered_tags[#filtered_tags+1] = t
                end
            end
            c:tags(filtered_tags)
            ret = filtered_tags
        else
            c.screen = atag.getscreen(tags) or c.screen
            c:tags({ tags })
            ret = { tags }
        end
        props.tag,props.tags = nil,nil
    end

    -- Switch to a tag or tags
    if props.switchtotag then
        local tags = get_property(c,"switchtotag",props.switchtotag,ignore_function)
        if type(tags) == "table" then
            -- Get all tag screens
            local screens = {}
            for k,t in ipairs(tags) do
                screens[atag.getscreen(t)] = true
            end

            -- Unselect all tags from those screens
            for s,v in pairs(screens) do
                atag.viewnone(s)
            end

            -- Select all tags
            for k,t in ipairs(tags) do
                t.selected = true
            end
        elseif type(tags) == "tag" then
            atag.viewonly(tags)
        else
            atag.viewmore(c:tags())
        end
        props.switchtotag = nil
    end

    -- Handle all geometry value
    for k,property in ipairs {"height","width","x","y"} do
        if props[property] then
            local geo = c:geometry()
            geo[property] = get_property(c,property, props[property],ignore_function)
            c:geometry(geo)
            props[property] = nil
        end
    end

    --Center client
    if props.centered then
        local value = get_property(c,"centered",props.centered,ignore_function)
        if value then
            aplacement.centered(c, nil)
        end
        props.centered = nil
    end

    --Set slave or master
    if props.slave or props.master then
        -- Both cannot be used at once, choose "slave"
        local property = props.slave and "slave" or "master"
        local value = get_property(c,property,props[property],ignore_function)
        if value then
            aclient["set"..property](c, true)
        end
        props.slave,props.master = nil,nil
    end

    -- Forward all other properties to the client itself
    for property, value in pairs(props) do
        local value = get_property(c,property, value, ignore_function)
        if type(c[property]) == "function" then
            c[property](c, value)
        else
            c[property] = value
        end
    end

    return ret
end

--- Apply properties, set a tag and call a callbacks for a client
-- @param c The client.
-- @param props Properties to apply.
-- @param callbacks Callbacks to apply (optional).
function rules.execute(c, props, callbacks)
    local focus = get_property(c,"focus",props.focus)
    props.focus = nil
    rules.apply_properties(c,props)

    -- If untagged, stick the client on the current one.
    if #c:tags() == 0 then
        atag.withcurrent(c)
    end

    -- Apply all callbacks.
    if callbacks then
        for i, callback in pairs(callbacks) do
            callback(c)
        end
    end

    -- Do this at last so we do not erase things done by the focus
    -- signal.
    if focus then
        c:emit_signal('request::activate')
    end
end

client.connect_signal("manage", rules.apply)
client.disconnect_signal("manage", atag.withcurrent)

return rules

-- vim: filetype=lua:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:textwidth=80
